// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

package oso

import "fmt"
import "encoding/json"
import "reflect"

type Call struct {
	// Args corresponds to the JSON schema field "args".
	Args []Term `json:"args"`

	// Kwargs corresponds to the JSON schema field "kwargs".
	Kwargs interface{} `json:"kwargs,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name Symbol `json:"name"`
}

type Constraints struct {
	// Operations corresponds to the JSON schema field "operations".
	Operations []Operation `json:"operations"`

	// Variable corresponds to the JSON schema field "variable".
	Variable Symbol `json:"variable"`
}

type Dictionary struct {
	// Fields corresponds to the JSON schema field "fields".
	Fields DictionaryFields `json:"fields"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceResult) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["formatted"]; !ok || v == nil {
		return fmt.Errorf("field formatted: required")
	}
	if v, ok := raw["trace"]; !ok || v == nil {
		return fmt.Errorf("field trace: required")
	}
	type Plain TraceResult
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = TraceResult(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Call) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	type Plain Call
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Call(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Operation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["args"]; !ok || v == nil {
		return fmt.Errorf("field args: required")
	}
	if v, ok := raw["operator"]; !ok || v == nil {
		return fmt.Errorf("field operator: required")
	}
	type Plain Operation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Operation(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Trace) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["children"]; !ok || v == nil {
		return fmt.Errorf("field children: required")
	}
	if v, ok := raw["node"]; !ok || v == nil {
		return fmt.Errorf("field node: required")
	}
	type Plain Trace
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Trace(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Operator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Operator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Operator, v)
	}
	*j = Operator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Rule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["body"]; !ok || v == nil {
		return fmt.Errorf("field body: required")
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name: required")
	}
	if v, ok := raw["params"]; !ok || v == nil {
		return fmt.Errorf("field params: required")
	}
	type Plain Rule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Rule(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Parameter) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["parameter"]; !ok || v == nil {
		return fmt.Errorf("field parameter: required")
	}
	type Plain Parameter
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Parameter(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Term) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["value"]; !ok || v == nil {
		return fmt.Errorf("field value: required")
	}
	type Plain Term
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Term(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Constraints) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["operations"]; !ok || v == nil {
		return fmt.Errorf("field operations: required")
	}
	if v, ok := raw["variable"]; !ok || v == nil {
		return fmt.Errorf("field variable: required")
	}
	type Plain Constraints
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Constraints(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalInstance) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["instance_id"]; !ok || v == nil {
		return fmt.Errorf("field instance_id: required")
	}
	type Plain ExternalInstance
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ExternalInstance(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *InstanceLiteral) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fields"]; !ok || v == nil {
		return fmt.Errorf("field fields: required")
	}
	if v, ok := raw["tag"]; !ok || v == nil {
		return fmt.Errorf("field tag: required")
	}
	type Plain InstanceLiteral
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = InstanceLiteral(plain)
	return nil
}

type DictionaryFields map[string]interface{}

type ExternalInstance struct {
	// Constructor corresponds to the JSON schema field "constructor".
	Constructor interface{} `json:"constructor,omitempty"`

	// InstanceId corresponds to the JSON schema field "instance_id".
	InstanceId int `json:"instance_id"`

	// Repr corresponds to the JSON schema field "repr".
	Repr interface{} `json:"repr,omitempty"`
}

type InstanceLiteral struct {
	// Fields corresponds to the JSON schema field "fields".
	Fields Dictionary `json:"fields"`

	// Tag corresponds to the JSON schema field "tag".
	Tag Symbol `json:"tag"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Dictionary) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["fields"]; !ok || v == nil {
		return fmt.Errorf("field fields: required")
	}
	type Plain Dictionary
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Dictionary(plain)
	return nil
}

type Node interface{}

type Numeric interface{}

type Operation struct {
	// Args corresponds to the JSON schema field "args".
	Args []Term `json:"args"`

	// Operator corresponds to the JSON schema field "operator".
	Operator Operator `json:"operator"`
}

type Operator string

const OperatorAdd Operator = "Add"
const OperatorAnd Operator = "And"
const OperatorAssign Operator = "Assign"
const OperatorCut Operator = "Cut"
const OperatorDebug Operator = "Debug"
const OperatorDiv Operator = "Div"
const OperatorDot Operator = "Dot"
const OperatorEq Operator = "Eq"
const OperatorForAll Operator = "ForAll"
const OperatorGeq Operator = "Geq"
const OperatorGt Operator = "Gt"
const OperatorIn Operator = "In"
const OperatorIsa Operator = "Isa"
const OperatorLeq Operator = "Leq"
const OperatorLt Operator = "Lt"
const OperatorMod Operator = "Mod"
const OperatorMul Operator = "Mul"
const OperatorNeq Operator = "Neq"
const OperatorNew Operator = "New"
const OperatorNot Operator = "Not"
const OperatorOr Operator = "Or"
const OperatorPrint Operator = "Print"
const OperatorRem Operator = "Rem"
const OperatorSub Operator = "Sub"
const OperatorUnify Operator = "Unify"

type Parameter struct {
	// Parameter corresponds to the JSON schema field "parameter".
	Parameter Term `json:"parameter"`

	// Specializer corresponds to the JSON schema field "specializer".
	Specializer interface{} `json:"specializer,omitempty"`
}

// Represents a pattern in a specializer or after isa.
type Pattern interface{}

type Rule struct {
	// Body corresponds to the JSON schema field "body".
	Body Term `json:"body"`

	// Name corresponds to the JSON schema field "name".
	Name Symbol `json:"name"`

	// Params corresponds to the JSON schema field "params".
	Params []Parameter `json:"params"`
}

type Symbol string

// Represents a concrete instance of a Polar value
type Term struct {
	// The actual underlying value
	Value interface{} `json:"value"`
}

type Trace struct {
	// Children corresponds to the JSON schema field "children".
	Children []Trace `json:"children"`

	// Node corresponds to the JSON schema field "node".
	Node TraceNode `json:"node"`
}

type TraceNode interface{}

type TraceResult struct {
	// Formatted corresponds to the JSON schema field "formatted".
	Formatted string `json:"formatted"`

	// Trace corresponds to the JSON schema field "trace".
	Trace Trace `json:"trace"`
}

type Value interface{}

var enumValues_Operator = []interface{}{
	"Debug",
	"Print",
	"Cut",
	"In",
	"Isa",
	"New",
	"Dot",
	"Not",
	"Mul",
	"Div",
	"Mod",
	"Rem",
	"Add",
	"Sub",
	"Eq",
	"Geq",
	"Leq",
	"Neq",
	"Gt",
	"Lt",
	"Unify",
	"Or",
	"And",
	"ForAll",
	"Assign",
}
